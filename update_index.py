#!/usr/bin/env python3.8

from __future__ import annotations
from typing import *  # NoQA

import dataclasses
import os
import pathlib
import re


CURRENT_DIR = pathlib.Path(__file__).parent
RFC_FILENAME = re.compile(r"^(?P<number>\d\d\d\d)-(?P<slug>[a-z0-9_-]+)\.rst$")
RFC_TITLE = re.compile(r"^RFC (?P<number>\d+)(: | - )(?P<title>.+)$")
HEADER_FIELD = re.compile(r"^ +(?P<name>[^:]+): (?P<value>.*)$")
HEADING = re.compile(r"^[=-~]+$")
AUTOGENERATED = "NOTE: This section is auto-generated with update_index.py"

if TYPE_CHECKING:
    Status = str

ACCEPTED_STATUSES: Set[Status] = {"active", "inactive", "final", "accepted"}
STATUSES: Set[Status] = ACCEPTED_STATUSES | {"rejected", "deferred", "draft"}


@dataclasses.dataclass
class RFC:
    number: int
    title: str
    status: Status
    filename: str

    @classmethod
    def from_file(cls, path: pathlib.Path) -> RFC:
        number = 0
        status = "unknown"
        title = "unknown"
        filename = path.name
        expected_length = 0

        # sm - state machine
        sm = [
            "before_preamble",
            "in_preamble",
            "before_title",
            "after_title",
        ]
        with path.open() as file:
            for line in file:
                line = line.rstrip()
                if sm[0] == "before_preamble":
                    if line == "..":
                        sm.pop(0)
                elif sm[0] == "in_preamble":
                    if m := HEADER_FIELD.match(line):
                        if m.group("name") == "Status":
                            status = m.group("value").lower()
                    else:
                        sm.pop(0)
                elif sm[0] == "before_title":
                    if m := RFC_TITLE.match(line):
                        number = int(m.group("number"))
                        title = m.group("title")
                        expected_length = len(line)
                    elif HEADING.match(line):
                        if expected_length == 0:
                            # pre-heading overline
                            continue

                        if len(line) == expected_length:
                            sm.pop(0)
                        else:
                            # previous RFC title match, if any, was invalid
                            number = 0
                            title = "unknown"

                elif sm[0] == "after_title":
                    break

        if number == 0 or title == "unknown" or status not in STATUSES:
            raise LookupError(
                f"Invalid RFC document {path}: {number=} {title=} {status=}"
            )

        return RFC(
            number=number, title=title, status=status, filename=filename
        )


def list_rfcs(directory: pathlib.Path) -> Dict[Status, List[RFC]]:
    result: Dict[Status, List[RFC]] = {}
    for file in os.listdir(directory):
        if not RFC_FILENAME.match(file):
            continue

        rfc = RFC.from_file(directory / file)
        status = rfc.status
        if status in ACCEPTED_STATUSES:
            status = "accepted"
        result.setdefault(status, []).append(rfc)
    for rfcs in result.values():
        rfcs.sort(key=lambda elem: elem.number)

    return result


def patch_readme(readme: pathlib.Path, rfcs: Dict[Status, List[RFC]]) -> None:
    lines: List[str] = []
    # sm - state machine
    sm = ["before_rfc_list", "in_rfc_list", "after_rfc_list"]
    with readme.open() as original:
        for line in original:
            if sm[0] == "before_rfc_list":
                lines.append(line)
                if line.rstrip() == "## List of RFCs":
                    sm.pop(0)
            elif sm[0] == "in_rfc_list":
                if line.startswith("## "):
                    sm.pop(0)
                    lines.append(f'[//]: # "{AUTOGENERATED}"\n\n')
                    if "draft" in rfcs:
                        lines.append("### Current Drafts\n")
                        for r in rfcs["draft"]:
                            lines.append(
                                f"* [RFC {r.number} - {r.title}]"
                                f"(./text/{r.filename})\n"
                            )
                        lines.append("\n")
                    if "accepted" in rfcs:
                        lines.append("### Accepted\n")
                        for r in rfcs["accepted"]:
                            lines.append(
                                f"* [RFC {r.number} - {r.title}]"
                                f"(./text/{r.filename}) ({r.status})\n"
                            )
                        lines.append("\n")
                    if "deferred" in rfcs:
                        lines.append("### Deferred\n")
                        for r in rfcs["Deferred"]:
                            lines.append(
                                f"* [RFC {r.number} - {r.title}]"
                                f"(./text/{r.filename})\n"
                            )
                        lines.append("\n")
                    if "rejected" in rfcs:
                        lines.append("### Rejected\n")
                        for r in rfcs["rejected"]:
                            lines.append(
                                f"* [RFC {r.number} - {r.title}]"
                                f"(./text/{r.filename})\n"
                            )
                        lines.append("\n")
                    lines.append(line)
            elif sm[0] == "after_rfc_list":
                lines.append(line)

    with readme.open("w") as new:
        for line in lines:
            new.write(line)


def main() -> None:
    rfcs = list_rfcs(CURRENT_DIR / "text")
    patch_readme(CURRENT_DIR / "README.md", rfcs)


if __name__ == "__main__":
    main()
