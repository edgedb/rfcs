..
    Status: Draft
    Type: Feature
    Created: 2020-01-28
    RFC PR: `edgedb/rfcs#0001 <https://github.com/edgedb/rfcs/pull/1>`_

====================
RFC 1000: Migrations
====================

This RFC describes the design and implementation of schema migrations in
EdgeDB.  This includes related EdgeQL commands, command-line tooling and
some considerations for framework integration.

Motivation
==========

EdgeDB maintains a strict database schema.  This provides strong data integrity
guarantees, code validation and makes the schema a single source of truth.
However, changing the schema requires applying a certain amount of effort and
having a process, both in development and for deployments.

EdgeDB needs to have complete support for schema migrations as a built-in
feature because:

* the database server is the best place to generate, validate and record
  schema migrations, since all mechanisms to ensure schema and data integrity
  are already there;

* built-in support and tools are language- and platform-agnostic, and the
  database users are not tied to a particular framework or library that
  implements migrations as a purely client-side concern.

Overview
========

EdgeDB maintains changes to a database schema as a linear history of
migrations.  A migration is essentially an EdgeQL script that performs
the necessary transformations using DDL and, possibly, regular queries.
In the database, the migrations are recorded as ``sys::Migration`` objects::

    type sys::Migration {
        # Migration description.
        property message -> str;
        # Parent migrations.
        multi link parents -> sys::Migration;
        # Migration script.
        property script -> array<str>;
    }

The recommended way to define the EdgeDB schema is via SDL files that are
committed into the repository of a project that uses EdgeDB.  The canonical
location for the schema files is the ``dbschema/`` directory in the project's
root folder.

The ``edgedb create-migration`` command reads the files in the schema folder
and creates the migration script with the help of the database server.
Migration scripts are stored to the ``dbschema/migrations/`` directory and
can be committed into the project's repository.  Migration files contain
valid EdgeQL text and can be modified by the user directly, for example, to
insert data migration queries.

The ``create-migration`` command is normally interactive and relies on the
user to provide input in schenarios where the migration is either ambiguous,
or impossible without a data migration.

The ``edgedb migrate`` command is used to bring the database schema to the
specified migration state.  By default, it applies all unapplied migrations
from ``dbschema/migrations/``, but can also be used to migrate to a specified
point in the migration history, possibly reversing migrations that have already
been applied.

The ``edgedb show-status`` command is used to show the current migration
state: whether all recorded migrations have been applied on the server, and
whether there are untracked changes in the local schema that require a
new migration.


Implementation
==============

All migration operations are implemented as EdgeQL statements, no protocol
modifications are necessary.

There are three ways to create and apply a migration:

1. The ``CREATE MIGRATION { ... }`` statement that is used to
   record and apply a previously generated migration.  This is the statement
   used by ``edgedb migrate`` to record and apply new migrations.

2. The ``START MIGRATION TO <schema>; ... COMMIT MIGRATION`` block
   that allows generating migrations using the target SDL specification and
   a set of special commands.  This statement is used by the
   ``edgedb create-migration`` command to generate a migration to a given
   schema state.

3. Any DDL statement executed outside of an explicit migration command creates
   an anonymous migration by wrapping itself with an implicit
   ``CREATE MIGRATION``.

CREATE MIGRATION
----------------

Synopsis::

    CREATE MIGRATION [ <id> ] [ FROM <parent-id> ] "{"
        { SET MESSAGE <message> | <subcommand> }
        [...]
    "}" ;

    # where
    #   <id>
    #      the migration UUID, autogenerated if not specified;
    #   <parent-id>
    #      optional id of a parent migration, it is an error
    #      to specify any parent other than the last applied
    #      migration;
    #   <message>
    #      optional migration message
    #   <subcommand>
    #      any valid DDL, DML or query, except CONFIGURE,
    #      MIGRATION and TRANSACTION statements.

``CREATE MIGRATION`` executes its body as a normal EdgeQL script and creates
a corresponding ``sys::Migration`` object.  The statement is transactional,
i.e it either succeedes fully or not at all.

START MIGRATION
---------------

Synopsis::

    START MIGRATION [ <id> ] [ FROM <parent-id> ] TO "{"
        <sdl-declaration> ;
    "}" ;

The ``START MIGRATION`` statement starts a *migration block*, where the
``<sdl-declaration>`` is the desired target state of the database schema as
an SDL declaration.  A transaction is started if none is running already,
otherwise the statement creates a transaction savepoint.  In either case
the migration block is either committed successfully, or not at all.
Migration ``<id>`` may be specified explicitly, and is generated otherwise.
Similarly to ``CREATE MIGRATION``, ``<parent-id>``, if specified, must refer
to the latest committed migration.  The ``<parent-id>`` is verified again
when ``COMMIT MIGRATION`` is ran to ensure that the migration is still valid.

While the migration block is active:

* DDL, DML and query statements are *not executed immediately*, and
  are instead recorded to be part of the final migration text.  To clarify:
  the DDL commands do affect the session schema state, so subsequent statements
  are interpreted as if the preceding DDL commands were applied.
  Like with ``CREATE MIGRATION``, configuration, migration and transaction
  control statements are not allowed, with the exception of
  ``DECLARE SAVEPOINT`` and ``ROLLBACK TO SAVEPOINT``.

* The ``DESCRIBE CURRENT MIGRATION AS JSON`` statement returns a complete
  description of the current migration: statements that have already been
  recorded to be part of the migration script as well as automatically
  generated list of statements required to complete the migration.  See
  the "DESCRIBE MIGRATION" section below for details.

* The ``POPULATE MIGRATION`` statement uses the statements suggested by
  the database server to complete the migration.

* If an error occurs when the migration block is active, the client can either
  abort the migration with ``ABORT MIGRATION``, or rollback to a known
  savepoint with ``ROLLBACK TO SAVEPOINT``.

* Once the migration script is complete, ``COMMIT MIGRATION`` runs it and
  records the migration.

DESCRIBE MIGRATION
------------------

Synopsis::

    DESCRIBE CURRENT MIGRATION AS JSON;

This is a special form of the ``DESCRIBE MIGRATION`` statement that is valid
only inside a migration block. It returns a full description of the current
migration block: statements that have already been recorded to be part of the
migration, as well as the generated list of statements required to complete
the migration.

The latter may possibly contain *alternatives* for statements
where there is no certainty, i.e. an ``ALTER`` vs a ``DROP + CREATE``.
Additionally, each DDL statement may be accompanied by other metadata, such
as the indication to provide a data migration expression for alterations
that require it.

The returned JSON conforms to the following pseudo-schema::

    {
      // List of confirmed migration statements
      "confirmed": [
        "<stmt text>",
        ...
      ],

      // List of proposed migration steps
      "proposed": [{
        // List of proposed variants for the migration step
        "variants": [{
          "statements": [{
            "text": "<stmt text template>",
            "required-user-input": [{
              "name": "<placeholder variable>",
              "prompt": "<statement prompt>",
            }]
          }],
          "confidence": (0..1) // confidence coefficient
          "prompt": "<variant prompt>"
        }, ... ]
      }, ... ]
    }

    Where:

      <stmt text>:
        Regular statement text.
      <stmt text template>:
        Statement text template with interpolation points using the \(name)
        syntax.
      <placeholder variable>:
        The name of an interpolation variable in the statement text template
        for which the user prompt is given.
      <statement prompt>:
        The text of a user prompt for an interpolation variable.
      <variant prompt>:
        Prompt for the proposed migration step variant.

Example::

    {
      "confirmed": [
        "CREATE TYPE User { CREATE PROPERTY name -> str }"
      ],

      "proposed": [{
        "variants": [{
          "statements": [{
            "text": "ALTER TYPE Address " +
                    "ALTER PROPERTY number " +
                    "SET TYPE int64 USING \(expr)",
            "required-user-input": [{
              "name": "expr",
              "prompt": "Altering Address.number to type " +
                        "int64 requires an explicit conversion expression",
            }]
          }],
          "confidence": 0.6
          "prompt": "Did you alter the Address.number property?"
        }, {
          "statements": [{
            "text": "ALTER TYPE Address { " +
                    "DROP PROPERTY number; " +
                    "CREATE PROPERTY number -> int64; }"
          }],
          "confidence": 0.4
        }]
      }]
    }

Migration operation classification
----------------------------------

The migrations system classifies the migrations operations into two categories:
safe and unsafe, based on whether the operation is automatically reversible
without losing any prior data.  For example, all ``CREATE`` operations are
considered safe by definition, but also alterations to schema that doesn't
involve data mutation, such as annotations, indexes, etc.  All other operations
are classified as unsafe.

Unsafe operations require confirmation in the interactive flows, and raise
an error in non-interactive flows (unless ``--allow-unsafe`` is specified).

REVERT SCHEMA
-------------

The ``REVERT SCHEMA`` statement is used to revert the schema to a state
at a given migration.  Migrations committed after the specified migrations
are reverted in reverse order, and reverts are recorded as migrations
themselves.  Each affected migration must be reversible.

Synopsis::

    REVERT SCHEMA TO <migration-id> ;

RESET SCHEMA
------------

The ``RESET SCHEMA`` statement is used to *reset* the schema to a state
at a given migration.  The difference from ``REVERT SCHEMA`` is that affected
migrations are *not* recorded as reverts, and the resulting state looks like
they never have been applied at all.  Each affected migration must be
reversible.

Synopsis::

    RESET SCHEMA TO <migration-id> ;

Bare DDL
--------

Each individual DDL command executed outside a migration block gets wrapped
into an implicit ``CREATE MIGRATION`` regardless of whether it is a part of a
transaction or not.  This is necessary to correctly track the state of the
schema.

Use of bare DDL for the purpose of schema migrations is discouraged.
To enforce a "no-bare-DDL" policy, the ``allow_bare_ddl`` configuration option
may be set to ``false``, which will prohibit all DDL operations outside of
migration blocks.

Discussion
==========

Downsides of the selected approach
----------------------------------

The apprach described in this RFC requires a server connection to generate
migrations.

Design considerations
---------------------

``ABORT MIGRATION`` is chosen instead of ``ROLLBACK MIGRATION``, or even
``ROLLBACK`` because the first can be confused with a migration revert command,
and ``ROLLBACK`` would terminate the entire transaction, whereas the
migration block might only be a subset of it.

The identifiers of the schema objects are not preserved in the migration,
because those are internal to the database instance and should generally not
be relied upon by the clients.  This is similar to OID values in Postgres.

The current design does not allow multiple migration parents (i.e. migration
history merges), but neither does it prohibit the concept as a future
feature.

A variant of ``START TRANSACTION`` without an explicit schema target was
considered to create a "free form" migration using DDL statements, but it's
unclear if such a feature is useful at this moment.